<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functional-Programming - Joser&#39;s Elixir</title>
    <meta name="description" content="Exploring the world of Elixir development, functional programming, and software engineering">

    
    <link rel="stylesheet" href="/css/custom.css">

    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <link rel="alternate" type="application/rss+xml" href="http://localhost:1313/tags/functional-programming/index.xml" title="Joser's Elixir" />
    </head>
<body>
    <header class="site-header">
        <div class="header-container">
            <div class="site-branding">
                <a href="http://localhost:1313/" class="site-title">Joser&#39;s Elixir</a>
            </div>

            <nav class="site-navigation">
                
                <a href="/">Home</a>
                
                <a href="/posts/">Posts</a>
                
                <a href="/about/">About</a>
                
            </nav>
        </div>
    </header>

    <main class="main-content">
        
<div class="list-page">
    <header class="page-header">
        <h1>Functional-Programming</h1>
        
    </header>

    <div class="post-list">
        
        <article class="post-list-item">
            <h2><a href="/posts/fp-series-pattern-matching/">Part Four | Functional Programming Through Elixir: Pattern Matching</a></h2>

            <div class="post-meta">
                <time datetime="2026-02-17">February 17, 2026</time>
                
                <span class="reading-time">11 min read</span>
            </div>

            
            <div class="post-summary">
                <h2 id="a-different-way-to-work-with-data">A Different Way to Work with Data</h2>
<p>In <a href="/posts/fp-series-immutability-vs-mutable-state/">Part One</a>, we explored immutability. In <a href="/posts/fp-series-functions-as-first-class-citizens/">Part Two</a>, we saw functions as values. In <a href="/posts/fp-series-pure-functions-vs-side-effects/">Part Three</a>, we learned about pure functions and side effects. Now we&rsquo;ll tackle one of the most distinctive features of functional programming: <strong>pattern matching</strong>.</p>
<p>Pattern matching is Elixir&rsquo;s superpower for working with data. It&rsquo;s not just a fancy way to assign variables - it&rsquo;s a fundamentally different approach to extracting, validating, and routing data through your program. Once you understand pattern matching, you&rsquo;ll find conditionals, type checking, and data extraction in OOP languages feel unnecessarily verbose.</p>
            </div>
            

            <a href="/posts/fp-series-pattern-matching/" class="read-more">Read More</a>
        </article>
        
        <article class="post-list-item">
            <h2><a href="/posts/fp-series-pure-functions-vs-side-effects/">Part Three | Functional Programming Through Elixir: Pure Functions vs Side Effects</a></h2>

            <div class="post-meta">
                <time datetime="2026-02-13">February 13, 2026</time>
                
                <span class="reading-time">9 min read</span>
            </div>

            
            <div class="post-summary">
                <h2 id="the-foundation-of-predictable-code">The Foundation of Predictable Code</h2>
<p>In the <a href="/posts/fp-series-immutability-vs-mutable-state/">first post</a>, we explored immutability. In the <a href="/posts/fp-series-functions-as-first-class-citizens/">second post</a>, we saw how functions are values. Now we&rsquo;ll tackle a concept that ties them together: <strong>pure functions</strong>.</p>
<p>Pure functions are the building blocks of functional programming. They&rsquo;re predictable, testable, and easy to reason about. But real applications need side effects - saving to databases, making HTTP requests, printing to the console. The key is knowing how to write pure functions and where to isolate side effects.</p>
            </div>
            

            <a href="/posts/fp-series-pure-functions-vs-side-effects/" class="read-more">Read More</a>
        </article>
        
        <article class="post-list-item">
            <h2><a href="/posts/fp-series-functions-as-first-class-citizens/">Part Two | Functional Programming Through Elixir: Functions as First-Class Citizens</a></h2>

            <div class="post-meta">
                <time datetime="2026-02-04">February 4, 2026</time>
                
                <span class="reading-time">9 min read</span>
            </div>

            
            <div class="post-summary">
                <h2 id="functions-are-values">Functions Are Values</h2>
<p>In the <a href="/posts/fp-series-immutability-vs-mutable-state/">first post</a>, we explored how immutability changes the way we think about data. Now we&rsquo;ll tackle another fundamental shift: <strong>in functional programming, functions are values just like numbers, strings, or lists</strong>. You can pass them as arguments, return them from other functions, store them in variables, and put them in data structures.</p>
<p>If you&rsquo;re coming from object-oriented programming, you&rsquo;ve probably encountered this concept through callbacks, lambdas, or method references. But in OOP, these often feel like workarounds or special cases. In functional programming languages like Elixir, treating functions as first-class citizens is natural and central to how you write code.</p>
            </div>
            

            <a href="/posts/fp-series-functions-as-first-class-citizens/" class="read-more">Read More</a>
        </article>
        
        <article class="post-list-item">
            <h2><a href="/posts/fp-series-immutability-vs-mutable-state/">Part One | Functional Programming Through Elixir: Immutability vs Mutable State</a></h2>

            <div class="post-meta">
                <time datetime="2026-02-02">February 2, 2026</time>
                
                <span class="reading-time">8 min read</span>
            </div>

            
            <div class="post-summary">
                <h2 id="the-foundation-of-functional-programming">The Foundation of Functional Programming</h2>
<p>If you&rsquo;re coming from an object-oriented programming background, one of the most fundamental shifts in thinking when learning functional programming is <strong>immutability</strong>. In Elixir and other functional languages, data never changes once it&rsquo;s created. This might sound limiting at first, but it&rsquo;s actually a superpower that unlocks predictability, thread safety, and easier debugging.</p>
<p>This is the first post in a series exploring functional programming concepts through Elixir, aimed at developers transitioning from OOP paradigms.</p>
            </div>
            

            <a href="/posts/fp-series-immutability-vs-mutable-state/" class="read-more">Read More</a>
        </article>
        
    </div>
</div>

    </main>

    <footer class="site-footer">
        <div class="footer-container">
            <p>&copy; 2026 Joser&#39;s Elixir. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>